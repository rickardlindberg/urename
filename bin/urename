#!/usr/bin/env python
# This file is automatically generated.
# Check out https://github.com/rickardlindberg/urename for the complete source code.
from optparse import OptionParser

class Options(object):

    def __init__(self):
        usage = "usage: %prog [options] src dest"
        parser = OptionParser(usage)
        (options, args) = parser.parse_args()
        if len(args) == 2:
            self.src = File(args[0])
            self.dest = File(args[1])
        else:
            parser.error("requires src and dest")
class File(object):

    def __init__(self, path):
        self.path = path
import os.path
import re
import subprocess
import sys


class MoveTask(object):

    def __init__(self, src_path, dest_path):
        self.src_path = src_path
        self.dest_path = dest_path

    def perform(self):
        if self._can_be_done() and ask(self._question()):
            if not self._create_dest_dir():
                return False
            if not self._move_file():
                return False
        return True

    def _can_be_done(self):
        return os.path.exists(self.src_path)

    def _question(self):
        return "mv %s %s" % (self.src_path, self.dest_path)

    def _create_dest_dir(self):
        src_dir = os.path.dirname(self.src_path)
        dest_dir = os.path.dirname(self.dest_path)
        if src_dir == dest_dir:
            return True
        else:
            create_cmd = ["mkdir", "-p", dest_dir]
            return subprocess.call(create_cmd) != 0

    def _move_file(self):
        move_cmd = ["mv", self.src_path, self.dest_path]
        return subprocess.call(move_cmd) == 0


class SubstituteTask(object):

    def __init__(self, files, a, b):
        self.files = files
        self.a = a
        self.b = b
        self.find_pattern = re.compile(r"\b%s\b" % a.replace(".", r"\."))

    def perform(self):
        try:
            for filename in self.files:
                if os.path.exists(filename):
                    self._sub_file(filename)
            return True
        except Exception, e:
            print e
            return False

    def _sub_file(self, filename):
        lines = read_lines(filename)
        new_lines = [self._sub_line(filename, line) for line in lines]
        write_lines(filename, new_lines)

    def _sub_line(self, filename, line):
        match = self.find_pattern.search(line)
        if match and ask(self._question(filename, line)):
            return self.find_pattern.sub(self.b, line)
        else:
            return line

    def _question(self, filename, line):
        return "substitute: %s -> %s\n\t%s: %s" % (
            self.a, self.b, filename, line)


def read_lines(filename):
    f = open(filename, "r")
    lines = f.readlines()
    f.close()
    return lines


def write_lines(filename, lines):
    f = open(filename, "w")
    f.writelines(lines)
    f.close()
def analyze(src, dest):
    plugin_tasks = get_plugin(src, dest).tasks(src, dest)
    return [MoveTask(src.path, dest.path)] + plugin_tasks
def find(path):
    all_files = []
    for (root, dirs, files) in os.walk(path):
        all_files += filter(include, [os.path.join(root, x) for x in files])
    return all_files


def include(filepath):
    if ".git/" in filepath:
        return False
    if ".swp" in filepath:
        return False
    if filepath.endswith(".pyc"):
        return False
    if filepath.endswith(".class"):
        return False
    if os.path.basename(filepath) == "tags":
        return False
    if is_binary(filepath):
        return False
    return True


def is_binary(filename):
    """
    Return true if the given filename appears to be binary.
    File is considered to be binary if it contains a NULL byte.
    FIXME: This approach incorrectly reports UTF-16 as binary.
    """
    with open(filename, 'rb') as f:
        for block in f:
            if '\0' in block:
                return True
    return False
plugins = []


def register_plugin(plugin):
    plugins.append(plugin)


def get_plugin(src, dest):
    for plugin in plugins:
        if plugin.use(src, dest):
            return plugin
class PythonPlugin(object):

    def use(self, src, dest):
        return src.path.endswith(".py")

    def tasks(self, src, dest):
        all_files = find(".")
        py_files = [x for x in all_files if x.endswith(".py")]
        old = os.path.basename(src.path)[:-3]
        new = os.path.basename(dest.path)[:-3]
        return [
            SubstituteTask(py_files, "import %s" % old, "import %s" % new),
            SubstituteTask(all_files, src.path, dest.path),
        ]


#register_plugin(PythonPlugin())
class HaskellPlugin(object):

    def use(self, src, dest):
        return src.path.endswith(".hs")

    def tasks(self, src, dest):
        print self._find_module_name(src.path)
        all_files = find(".")
        py_files = [x for x in all_files if x.endswith(".py")]
        old = os.path.basename(src.path)[:-3]
        new = os.path.basename(dest.path)[:-3]
        return [
            SubstituteTask(py_files, "import %s" % old, "import %s" % new),
            SubstituteTask(all_files, src.path, dest.path)
        ]

    def _find_module_name(self, path):
        f = open(path)
        content = f.read()
        f.close()
        return extract_module_name_parts(content)


def extract_module_name_parts(content):
    match = re.search(r"^module *([a-zA-Z0-9.]+) *", content)
    if match:
        return match.group(1).split(".")
    else:
        return []


def extract_root(filename, parts):
    if parts:
        (head, tail) = os.path.split(filename)
        return extract_root(head, parts[:-1])
    else:
        return filename


#register_plugin(HaskellPlugin())
class GeneralPlugin(object):

    def use(self, src, dest):
        return True

    def tasks(self, src, dest):
        all_files = find(".") + [dest.path]
        src_base = os.path.splitext(os.path.basename(src.path))[0]
        dest_base = os.path.splitext(os.path.basename(dest.path))[0]
        return [
            SubstituteTask(all_files, src.path, dest.path),
            SubstituteTask(all_files, src_base, dest_base),
        ]


register_plugin(GeneralPlugin())
def run_tasks(tasks):
    for task in tasks:
        if not task.perform():
            sys.exit(1)


def ask(question):
    print question, "[Y/n]",
    answer = raw_input()
    if answer == "":
        return True
    elif answer.lower() == "y":
        return True
    elif answer.lower() == "n":
        return False
    else:
        return ask(question)


if __name__ == "__main__":
    o = Options()
    run_tasks(analyze(o.src, o.dest))
