#!/usr/bin/env python
# This file is automatically generated.
# Check out https://github.com/rickardlindberg/urename for the complete source code.
from optparse import OptionParser

class Options(object):

    def __init__(self):
        usage = "usage: %prog [options] src dest"
        parser = OptionParser(usage)
        (options, args) = parser.parse_args()
        if len(args) == 2:
            self.src = File(args[0])
            self.dest = File(args[1])
        else:
            parser.error("requires src and dest")
class File(object):

    def __init__(self, path):
        self.path = path
import os.path
import re
import subprocess
import sys


class MoveTask(object):

    def __init__(self, src, dest):
        self.src = src
        self.dest = dest

    def perform(self):
        if self.can_be_done() and ask(self.question()):
            if os.path.dirname(self.src) != os.path.dirname(self.dest) and subprocess.call(["mkdir", "-p", os.path.dirname(self.dest)]) != 0:
                return False
            if subprocess.call(["mv", self.src, self.dest]) != 0:
                return False
        return True

    def can_be_done(self):
        return os.path.exists(self.src)

    def question(self):
        return "mv %s %s" % (self.src, self.dest)


class SubstituteTask(object):

    def __init__(self, files, a, b):
        self.files = files
        self.a = a
        self.b = b
        self.find_pattern = re.compile(r"\b%s\b" % a.replace(".", r"\."))

    def perform(self):
        try:
            for filename in self.files:
                if os.path.exists(filename):
                    f = open(filename, "r")
                    lines = f.readlines()
                    f.close()

                    def foo(line):
                        match = self.find_pattern.search(line)
                        if match and ask(self.question(filename, line)):
                            return self.find_pattern.sub(self.b, line)
                        return line
                    lines = [foo(line) for line in lines]

                    f = open(filename, "w")
                    f.writelines(lines)
                    f.close()

            return True
        except Exception, e:
            print e
            return False

    def question(self, filename, line):
        return "substitute: %s -> %s\n\t%s: %s" % (
            self.a, self.b, filename, line)
def analyze(src, dest):
    plugin_tasks = get_plugin(src, dest).tasks(src, dest)
    return [MoveTask(src.path, dest.path)] + plugin_tasks
def find(path):
    all_files = []
    for (root, dirs, files) in os.walk(path):
        all_files += filter(include, [os.path.join(root, x) for x in files])
    return all_files


def include(filepath):
    if ".git/" in filepath:
        return False
    if ".swp" in filepath:
        return False
    if os.path.basename(filepath) == "tags":
        return False
    return True
plugins = []


def register_plugin(plugin):
    plugins.append(plugin)


def get_plugin(src, dest):
    for plugin in plugins:
        if plugin.use(src, dest):
            return plugin
class PythonPlugin(object):

    def use(self, src, dest):
        return src.path.endswith(".py")

    def tasks(self, src, dest):
        all_files = find(".")
        py_files = [x for x in all_files if x.endswith(".py")]
        old = os.path.basename(src.path)[:-3]
        new = os.path.basename(dest.path)[:-3]
        return [
            SubstituteTask(py_files, "import %s" % old, "import %s" % new),
            SubstituteTask(all_files, src.path, dest.path),
        ]


#register_plugin(PythonPlugin())
class HaskellPlugin(object):

    def use(self, src, dest):
        return src.path.endswith(".hs")

    def tasks(self, src, dest):
        print self._find_module_name(src.path)
        all_files = find(".")
        py_files = [x for x in all_files if x.endswith(".py")]
        old = os.path.basename(src.path)[:-3]
        new = os.path.basename(dest.path)[:-3]
        return [
            SubstituteTask(py_files, "import %s" % old, "import %s" % new),
            SubstituteTask(all_files, src.path, dest.path)
        ]

    def _find_module_name(self, path):
        f = open(path)
        content = f.read()
        f.close()
        return extract_module_name_parts(content)


def extract_module_name_parts(content):
    match = re.search(r"^module *([a-zA-Z0-9.]+) *", content)
    if match:
        return match.group(1).split(".")
    else:
        return []


def extract_root(filename, parts):
    if parts:
        (head, tail) = os.path.split(filename)
        return extract_root(head, parts[:-1])
    else:
        return filename


#register_plugin(HaskellPlugin())
class GeneralPlugin(object):

    def use(self, src, dest):
        return True

    def tasks(self, src, dest):
        all_files = find(".")
        src_base = os.path.splitext(os.path.basename(src.path))[0]
        dest_base = os.path.splitext(os.path.basename(dest.path))[0]
        return [
            SubstituteTask(all_files, src.path, dest.path),
            SubstituteTask(all_files, src_base, dest_base),
        ]


register_plugin(GeneralPlugin())
def run_tasks(tasks):
    for task in tasks:
        if not task.perform():
            sys.exit(1)


def ask(question):
    print question, "[Y/n]",
    answer = raw_input()
    if answer == "":
        return True
    elif answer.lower() == "y":
        return True
    elif answer.lower() == "n":
        return False
    else:
        return ask(question)


if __name__ == "__main__":
    o = Options()
    run_tasks(analyze(o.src, o.dest))
